<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222"/>
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2"/>

<link rel="stylesheet" href="/css/main.css?v=7.1.2"/>


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.2">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.2" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="第 1 章 面试的流程1. 简历中描述项目的 STAR 模型a. Situation 简短的项目背景。比如项目的规模，开发的软件的功能、目标用户等。 b. Task 自己完成的任务。在用词上要区分「参与」和「负责」，面试官看到简历上应聘者「负责」了某个项目，他可能就会问项目的总体框架设计、核心算法、团队合作等问题。 c. Action 为完成任务做了哪些工作，是怎么做的。做系统设计的，可以介绍系统">
<meta property="og:type" content="article">
<meta property="og:title" content="《剑指 Offer 第 2 版》读书笔记（一）">
<meta property="og:url" content="http://yoursite.com/2018/06/23/%E3%80%8A%E5%89%91%E6%8C%87%20Offer%20%E7%AC%AC%202%20%E7%89%88%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/index.html">
<meta property="og:site_name" content="mayan&#96;s blog">
<meta property="og:description" content="第 1 章 面试的流程1. 简历中描述项目的 STAR 模型a. Situation 简短的项目背景。比如项目的规模，开发的软件的功能、目标用户等。 b. Task 自己完成的任务。在用词上要区分「参与」和「负责」，面试官看到简历上应聘者「负责」了某个项目，他可能就会问项目的总体框架设计、核心算法、团队合作等问题。 c. Action 为完成任务做了哪些工作，是怎么做的。做系统设计的，可以介绍系统">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mayan29.oss-cn-beijing.aliyuncs.com/%E3%80%8A%E5%89%91%E6%8C%87%20Offer%20%E7%AC%AC2%E7%89%88%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/IMG001.png">
<meta property="og:image" content="https://mayan29.oss-cn-beijing.aliyuncs.com/%E3%80%8A%E5%89%91%E6%8C%87%20Offer%20%E7%AC%AC2%E7%89%88%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/IMG002.png">
<meta property="og:image" content="https://mayan29.oss-cn-beijing.aliyuncs.com/%E3%80%8A%E5%89%91%E6%8C%87%20Offer%20%E7%AC%AC2%E7%89%88%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/IMG003.png">
<meta property="og:image" content="https://mayan29.oss-cn-beijing.aliyuncs.com/%E3%80%8A%E5%89%91%E6%8C%87%20Offer%20%E7%AC%AC2%E7%89%88%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/IMG004.png">
<meta property="og:image" content="https://mayan29.oss-cn-beijing.aliyuncs.com/%E3%80%8A%E5%89%91%E6%8C%87%20Offer%20%E7%AC%AC2%E7%89%88%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/IMG005.jpeg">
<meta property="og:image" content="https://mayan29.oss-cn-beijing.aliyuncs.com/%E3%80%8A%E5%89%91%E6%8C%87%20Offer%20%E7%AC%AC2%E7%89%88%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/IMG006.png">
<meta property="og:image" content="https://mayan29.oss-cn-beijing.aliyuncs.com/%E3%80%8A%E5%89%91%E6%8C%87%20Offer%20%E7%AC%AC2%E7%89%88%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/IMG007.png">
<meta property="article:published_time" content="2018-06-22T16:05:34.000Z">
<meta property="article:modified_time" content="2020-02-23T14:34:05.167Z">
<meta property="article:author" content="mayan">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mayan29.oss-cn-beijing.aliyuncs.com/%E3%80%8A%E5%89%91%E6%8C%87%20Offer%20%E7%AC%AC2%E7%89%88%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/IMG001.png">





  
  
  <link rel="canonical" href="http://yoursite.com/2018/06/23/%E3%80%8A%E5%89%91%E6%8C%87%20Offer%20%E7%AC%AC%202%20%E7%89%88%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>《剑指 Offer 第 2 版》读书笔记（一） | mayan`s blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">mayan`s blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br/>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br/>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br/>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/23/%E3%80%8A%E5%89%91%E6%8C%87%20Offer%20%E7%AC%AC%202%20%E7%89%88%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mayan"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mayan`s blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">《剑指 Offer 第 2 版》读书笔记（一）

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-06-23 00:05:34" itemprop="dateCreated datePublished" datetime="2018-06-23T00:05:34+08:00">2018-06-23</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-23 22:34:05" itemprop="dateModified" datetime="2020-02-23T22:34:05+08:00">2020-02-23</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="第-1-章-面试的流程"><a href="#第-1-章-面试的流程" class="headerlink" title="第 1 章 面试的流程"></a>第 1 章 面试的流程</h1><h2 id="1-简历中描述项目的-STAR-模型"><a href="#1-简历中描述项目的-STAR-模型" class="headerlink" title="1. 简历中描述项目的 STAR 模型"></a>1. 简历中描述项目的 STAR 模型</h2><p><strong>a.</strong> <strong>Situation 简短的项目背景。</strong>比如项目的规模，开发的软件的功能、目标用户等。</p>
<p><strong>b.</strong> <strong>Task 自己完成的任务。</strong>在用词上要区分「参与」和「负责」，面试官看到简历上应聘者「负责」了某个项目，他可能就会问项目的总体框架设计、核心算法、团队合作等问题。</p>
<p><strong>c.</strong> <strong>Action 为完成任务做了哪些工作，是怎么做的。</strong>做系统设计的，可以介绍系统架构的特点；做软件开发的，可以写基于什么工具在哪个平台下应用了哪些技术。</p>
<p><strong>d.</strong> <strong>Result 自己的贡献。</strong>这方面的信息最好能用数字加以说明，如果参与功能开发，可以说按时完成了多少功能；如果做优化，可以说性能提高的百分比是多少；如果是维护，可以说修改了多少个 Bug。</p>
<p>举个例子：Winforms 是微软 .NET 中的一个成熟的 UI 平台（ <strong>Situation</strong> ）。本人的工作是在添加少量新功能之外主要负责维护已有的功能（ <strong>Task</strong> ）。新的功能主要是让 Winforms 的控件风格和 Vista、Windows 7 的风格保持一致。在维护方面，对于较难的问题，我用 WinDbg 等工具进行调试（ <strong>Action</strong> ）。在过去两年中，我共修改了超过 200 个 Bug（ <strong>Result</strong> ）。</p>
<p>除此之外，面试官针对项目经验最常问的问题包括如下几个类型：</p>
<p><strong>a.</strong> 你在该项目中碰到最大的问题是什么，你是怎么解决的？<br><strong>b.</strong> 从这个项目中你学到了什么？<br><strong>c.</strong> 什么时候会和其他团队成员（包括开发人员、测试人员、设计人员、项目经理等）有什么样的冲突，你们是怎么解决冲突的？</p>
<h2 id="2-简历中技能的描述"><a href="#2-简历中技能的描述" class="headerlink" title="2. 简历中技能的描述"></a>2. 简历中技能的描述</h2><p>除应聘者参与过的项目之外，面试官可能针对简历上提到的技能提出问题，和描述项目时要注意「参与」和「负责」一样，描述技能掌握程度时也要注意「了解」、「熟悉」和「精通」的区别。</p>
<p><code>了解</code> 指对某项技术只是上过课或者看过书，但没有做过实际的项目。通常不建议在简历中列出只是肤浅地了解一点的技能，除非这项技术应聘的职位需要。</p>
<p><code>熟悉</code> 指在项目中使用某项技术已经有较长的时间，通过查阅相关的文档可以独立解决大部分问题。简历中我们描述技能的掌握程度大部分应该是「熟悉」。</p>
<p><code>精通</code> 指我们对一项技术使用的得心应手，在项目开发过程中，同事向我们请教这个领域的问题时，我们都有信心也有能力解决。</p>
<h2 id="3-回答「为什么跳槽」"><a href="#3-回答「为什么跳槽」" class="headerlink" title="3. 回答「为什么跳槽」"></a>3. 回答「为什么跳槽」</h2><p>笔者自己跳过几次槽，从 Autodesk 跳槽到微软，再从微软跳槽到思科，后来又从思科回到了微软。</p>
<p>在微软面试被问到为什么要跳槽时，笔者的回答是：我在 Autodesk 开发的软件 Civil 3D 是一款面向土木行业的设计软件。如果我想在现在的职位上得到提升，就必须加强土木行业的学习，可我对诸如计算土方量、道路设计等没有太多兴趣，因此出来寻找机会。</p>
<p>在微软工作两年半之后去思科面试的时候，笔者的回答是：我在微软的主要工作是开发和维护 .NET 的 UI 平台 Winforms。由于 Winforms 已经非常成熟，不需要添加多少新功能，因此我的大部分工作是维护和修改 Bug。两年下来，调试的能力得到了很大的提高，但长期如此，自己的软件开发和设计能力将不能得到提高，因此想出来寻找可以设计和开发系统的职位。同时，我在过去几年里的工作都是开发桌面软件，对网络了解甚少，因此希望下一个工作能与网络相关。众所周知，思科是一家网络公司，这里的软件和系统或多或少都离不开网络，因此我对思科的职位很感兴趣。</p>
<h2 id="4-技术面试环节"><a href="#4-技术面试环节" class="headerlink" title="4. 技术面试环节"></a>4. 技术面试环节</h2><p>面试官在通过简历及行为面试大致了解应聘者的背景之后，接下来就要开始技术面试了。总体来说他们都会关注应聘者的 5 种素质：</p>
<p><strong>a.</strong> <strong>基础知识扎实全面，包括编程语言、数据结构、算法。</strong>其中数据结构是考察的重点，应聘者需要熟练掌握链表、树、栈、队列和哈希表等数据结构，以及它们的操作。对于算法，大部分公司都会注重考查查找和排序，其中重点需要掌握二分查找、归并排序和快速排序，因为很多面试题都只是这些算法的变体而已。</p>
<p><strong>b.</strong> <strong>能写出正确的、完整的、鲁棒的高质量代码。</strong>技术面试的面试官一般都是程序员，他们通常没有那么多想法，题目做对、做完整了，就让你通过面试。所以，面试官除了希望应聘者的代码能够完成基本的功能，还会关注应聘者是否考虑了边界条件、特殊输入及错误处理。</p>
<p><strong>c.</strong> <strong>能思路清晰地分析、解决复杂问题。</strong>有时候面试官会有意出一些比较复杂的问题，甚至不期待应聘者能在面试不到一个小时的时间里给出完整的答案，他更看重的是应聘者是否有清晰的思路。所以我们可以：画图使抽象问题形象化，举例使抽象问题具体化，分解使复杂问题简单化。</p>
<p><strong>d.</strong> <strong>能从时间、空间复杂度两方面优化算法效率。</strong>想要优化代码的效率，我们需要熟知各种数据结构的优缺点，并能选择合适的数据结构解决问题。</p>
<p><strong>e.</strong> <strong>具备优秀的沟通能力、学习能力、发散思维能力等。</strong>随着软件系统的规模越来越大，软件开发已经告别了单打独斗的年代，程序员与他人的沟通变得越来越重要。在面试过程中，面试官会观察应聘者在介绍项目经验或者算法思路时是否观点明确、逻辑清晰，并以此判断其沟通能力的强弱。另外，面试官也会从应聘者说话的神态和语气来判断他是否有团队合作的意识。对于学习能力，通常面试官有两种办法考查应聘者的学习能力。第一种方法是询问应聘者最近在看什么书、从中学到了哪些新技术。第二种方法是抛出一个新概念，接下来会观察应聘者能不能在较短的时间内理解并解决相关的问题。</p>
<h2 id="5-回答「你还有什么问题吗」"><a href="#5-回答「你还有什么问题吗」" class="headerlink" title="5. 回答「你还有什么问题吗」"></a>5. 回答「你还有什么问题吗」</h2><p>推荐问的问题是与应聘的职位或者项目相关的问题。</p>
<h1 id="第-2-章-面试需要的基础知识"><a href="#第-2-章-面试需要的基础知识" class="headerlink" title="第 2 章 面试需要的基础知识"></a>第 2 章 面试需要的基础知识</h1><h2 id="1-数据结构-数组"><a href="#1-数据结构-数组" class="headerlink" title="1. 数据结构 - 数组"></a>1. 数据结构 - 数组</h2><p>数组可以说是最简单的一种数据结构，它占据一块连续的内存并按照顺序存储数据。创建数组时，我们首先指定数组的容量大小，然后根据大小分配内存。因此数组的空间效率不是很好，经常会有空闲的区域没有得到充分利用。</p>
<p>由于数组中的内存是连续的，于是可以根据下标在 O(1) 时间读 / 写任何元素，我们可以根据数组时间效率高的优点，用数组来实现简单的哈希表：把数组的下标设为哈希表的 key，数组中每一个数字设为哈希表的 value。</p>
<h3 id="面试题-3-1"><a href="#面试题-3-1" class="headerlink" title="面试题 3 - 1"></a>面试题 3 - 1</h3><p><strong>题目：找出数组中重复的数字。</strong>在一个长度为 n 的数组里的所有数字都在 0 ~ n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为 7 的数组 <code>{ 2, 3, 1, 0, 2, 5, 3 }</code>，那么对应的输出是重复的数字 <code>2</code> 或者 <code>3</code>。</p>
<p>方法一，将数组排序，然后从头到尾扫描排序后的数组就可以了。排序一个长度为 n 的数组的时间复杂度为 O(nlogn)。</p>
<p>方法二，从头到尾扫描数组的每个数字，每扫描到一个数字的时候，都可以用 O(1) 的时间来判断哈希表里是否已经包含了该数字，如果哈希表里还没有这个数字，就把它加入哈希表；如果哈希表里已经存在该数字，就找到一个重复的数字。这个算法的时间复杂度是 O(n)，但它提高时间效率是以一个大小为 O(n) 的哈希表为代价的。</p>
<p>方法三，如果这个数组中没有重复的数字，那么当数组排序之后数字 i 将出现在下标为 i 位置。现在让我们重排这个数组，从头到尾扫描数组的每个数字，首先比较这个数字 m 是不是等于 i，如果是，接着扫描下一个数字；如果不是，再拿它和第 m 个数字进行比较，如果它和第 m 个数字相等，就找到了一个重复的数字（该数字在下标为 i 和 m 的位置都出现了），如果它和第 m 个数字不相等，就把第 i 个数字和第 m 个数字交换，把 m 放到属于它的位置。接下来再重复这个比较、交换的过程，直到我们发现一个重复的数字。这个算法的时间复杂度是 O(n)，控件复杂度为 O(1)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (numbers == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[i] &lt; <span class="number">0</span> || numbers[i] &gt; length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (numbers[i] != i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[i] == numbers[numbers[i]]) &#123;</span><br><span class="line">                <span class="keyword">return</span> numbers[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 交换 numbers[i] 和 numbers[numbers[i]]</span></span><br><span class="line">            <span class="keyword">int</span> temp = numbers[i];</span><br><span class="line">            numbers[i] = numbers[temp];</span><br><span class="line">            numbers[temp] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> numbers[] = &#123; <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span> &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> duplication = duplicate(numbers, <span class="keyword">sizeof</span>(numbers) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (duplication &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"数组中没有重复的数字，或者输入无效\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"数组中有重复的数字，其中一个重复的数字为 %d\n"</span>, duplication);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="面试题-3-2"><a href="#面试题-3-2" class="headerlink" title="面试题 3 - 2"></a>面试题 3 - 2</h3><p><strong>题目：不修改数组找出重复的数字。</strong>在一个长度为 n 的数组里的所有数字都在 1 ~ n-1 的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为 7 的数组 <code>{ 2, 3, 5, 4, 3, 2, 6 }</code>，那么对应的输出是重复的数字 <code>2</code> 或者 <code>3</code>。</p>
<p>我们把从 1 ~ n-1 的数字从中间的数字 m 分为两部分，前面一半为 1 ~ m，后面一半为 m+1 ~ n-1。如果 1 ~ m 的数字的数目超过 m，那么这一半的区间里一定包含重复的数字；否则，另一半区间里一定包含重复的数字。我们继续把包含重复数字的区间一分为二，直到找到一个重复的数字。这个过程和二分查找算法类似，只是多了一步统计区间里数字的数目。这个算法的时间复杂度是 O(nlogn)，空间复杂度为 O(1)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDuplication</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* numbers, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (numbers == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> end = length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">int</span> middle = ((end - start) &gt;&gt; <span class="number">1</span>) + start;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[i] &gt;= start &amp;&amp; numbers[i] &lt;= middle) &#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> start;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (count &gt; (middle - start + <span class="number">1</span>)) &#123;</span><br><span class="line">            end = middle;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            start = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> numbers[] = &#123; <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> duplication = getDuplication(numbers, <span class="keyword">sizeof</span>(numbers) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (duplication &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"数组中没有重复的数字，或者输入无效\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"数组中有重复的数字，其中一个重复的数字为 %d\n"</span>, duplication);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="面试题-4"><a href="#面试题-4" class="headerlink" title="面试题 4"></a>面试题 4</h3><p><strong>题目：二维数组中的查找。</strong>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。例如，从下面的矩阵中查找数字 7</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1    2    8    9</span><br><span class="line">2    4    9    12</span><br><span class="line">4    7    10   13</span><br><span class="line">6    8    11   15</span><br></pre></td></tr></table></figure>

<p>首先选取数组中右上角的数字，如果该数字等于要查找的数字，则查找过程结束。如果该数字大于要查找的数字，则剔除这个数字所在的列。如果该数字小于要查找的数字，则剔除这个数字所在的行。这样每一步都可以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> matrix[<span class="number">4</span>][<span class="number">4</span>] = &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">9</span> &#125;, &#123; <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">12</span> &#125;, &#123; <span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">13</span> &#125;, &#123; <span class="number">6</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">15</span> &#125; &#125;;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">7</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> maxRow = <span class="keyword">sizeof</span>(matrix) / <span class="keyword">sizeof</span>(matrix[<span class="number">0</span>]) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxCol = <span class="keyword">sizeof</span>(matrix[<span class="number">0</span>]) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> col = maxCol;</span><br><span class="line">    <span class="keyword">while</span> (row &lt;= maxRow &amp;&amp; col &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[row][col] == number) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[row][col] &gt; number) &#123;</span><br><span class="line">            --col;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ++row;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (row &lt;= maxRow &amp;&amp; col &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"已找到数字 %d，坐标为 [%d, %d]\n"</span>, number, row, col);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"没有找到数字 %d\n"</span>, number);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-数据结构-字符串"><a href="#2-数据结构-字符串" class="headerlink" title="2. 数据结构 - 字符串"></a>2. 数据结构 - 字符串</h2><p>字符串是由若干字符组成的序列，C/C++ 中每个字符串都以字符 <code>\0</code> 作为结尾，这样我们就能很方便地找到字符串的最后尾部。但由于这个特点，每个字符串中都有一个额外字符的开销，稍不留神就会造成字符串的越界。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[] = <span class="string">"012345"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"字符串长度为 %lu\n"</span>, <span class="keyword">sizeof</span>(str));</span><br><span class="line"><span class="keyword">if</span> (str[<span class="number">6</span>] == <span class="string">'\0'</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"字符串最后一位为 '\\0'\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了节省内存，C/C++ 把常量字符串放到单独的一个内存区域，当几个指针赋值给相同的常量字符串时，它们实际上会指向相同的内存地址。但用常量内存初始化数组，情况却有所不同。运行下面的代码，得到的结果是什么？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str1[] = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">char</span> str2[] = <span class="string">"hello world"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* str3 = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">char</span>* str4 = <span class="string">"hello world"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (str1 == str2) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"str1 和 str2 相同\n"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"str1 和 str2 不相同\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (str3 == str4) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"str3 和 str4 相同\n"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"str3 和 str4 不相同\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>str1 和 str2 是两个字符串数组，我们会为它们分配两个长度为 12 字节的空间，并把 <code>hello world</code> 的内容分别复制到数组中去。这是两个初始地址不同的数组，因此 str1 和 str2 的值也不相同。输出 <code>str1 和 str2 不相同</code>。</p>
<p>str3 和 str4 是两个指针，我们无须为它们分配内存以存储字符串的内容，而只需要把它们指向 <code>hello world</code> 在内存中的地址就可以了。由于 <code>hello world</code> 是常量字符串，它在内存中只有一个拷贝，因此 str3 和 str4 指向的是同一个地址。输出 <code>str3 和 str4 相同</code>。</p>
<h3 id="面试题-5"><a href="#面试题-5" class="headerlink" title="面试题 5"></a>面试题 5</h3><p><strong>题目：替换空格。</strong>请实现一个函数，把字符串中的每个空格替换成 <code>%20</code>。例如，输入 <code>We are happy.</code> 则输出 <code>We%20are%20happy.</code>。</p>
<p>在网络编程中，如果 URL 参数中含有特殊字符，则可能导致服务器无法获得正确的参数值，我们需要将这些特殊符号转换成服务器可以识别的字符。转换的规则是在 <code>%</code> 后面跟上 ASCII 码的两位十六进制的表示。</p>
<p>方法一，从头到尾扫描字符串，每次碰到空格字符的时候进行替换。由于是把 1 个字符替换成 3 个字符，我们必须要把空格后面所有的字符都后移 2 字节，否则就有两个字符被覆盖了。假设字符串的长度是 n，对每个空格字符，需要移动后面 O(n) 个字符，因此对于含有 O(n) 个空格字符的字符串而言，总的时间效率是 O(n²)。</p>
<p>方法二，首先遍历一次字符串，统计出字符串中空格的总数，计算替换后的字符串的总长度。以前面的字符串 <code>We are happy</code> 为例，这个字符串的长度是 14（包括结尾符号 <code>\0</code>），里面有两个空格，因此替换之后字符串的长度是 18。</p>
<p>我们从字符串的后面开始复制和替换。首先准备两个指针 P1 和 P2，P1 指向原始字符串的末尾，P2 指向替换后的字符串的末尾。接下来我们向前移动指针 P1，逐个把它指向的字符复制到 P2 指向的位置。碰到空格之后，把 P1 向前移动 1 格，在 P2 之前插入字符串 <code>%20</code>，同时也要把 P2 向前移动 3 格。从上面的分析中可以看出，所有的字符都只复制（移动）一次，因此这个算法的时间效率是 O(n)，比第一个方法要快。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>] = <span class="string">"We are happy."</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;  <span class="comment">// 字符串的实际长度</span></span><br><span class="line">    <span class="keyword">int</span> newLength = <span class="number">0</span>;  <span class="comment">// 把空格替换成 '%20' 之后的长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(str) / <span class="keyword">sizeof</span>(<span class="keyword">char</span>); i++) &#123;</span><br><span class="line">        </span><br><span class="line">        length = length + <span class="number">1</span>;</span><br><span class="line">        newLength = newLength + ((str[i] == <span class="string">' '</span>) ? <span class="number">3</span> : <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">'\0'</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">int</span> index = length;</span><br><span class="line">    <span class="keyword">int</span> newIndex = newLength;</span><br><span class="line">    <span class="keyword">while</span> (index &gt;= <span class="number">0</span> &amp;&amp; newIndex &gt; index) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[index] == <span class="string">' '</span>) &#123;</span><br><span class="line">            str[newIndex--] = <span class="string">'0'</span>;</span><br><span class="line">            str[newIndex--] = <span class="string">'2'</span>;</span><br><span class="line">            str[newIndex--] = <span class="string">'%'</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            str[newIndex--] = str[index];</span><br><span class="line">        &#125;</span><br><span class="line">        --index;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-数据结构-链表"><a href="#3-数据结构-链表" class="headerlink" title="3. 数据结构 - 链表"></a>3. 数据结构 - 链表</h2><p>我们说链表是一种动态数据结构，是因为在创建链表时，无须知道链表的长度。当插入一个节点时，我们只需要为新节点分配内存，然后调整指针的指向来确保新节点被链接到链表当中。内存分配不是在创建链表时一次性完成的，而是每添加一个节点分配一次内存。由于没有闲置的内存，链表的空间效率比数组高。</p>
<h3 id="面试题-6"><a href="#面试题-6" class="headerlink" title="面试题 6"></a>面试题 6</h3><p><strong>题目：从尾到头打印链表。</strong>输入一个链表的头节点，从尾到头反过来打印出每个节点的值。链表节点定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> m_nKey;</span><br><span class="line">    ListNode* m_pNext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法一，很多人第一反应是从头到尾输出将会比较简单，于是我们很自然地想到把链表中的链接节点的指针反转过来，改变链表的方向，然后就可以从头到尾输出了。但是是否允许在打印链表的时候修改链表的结构，这取决于面试官的要求，因此在面试的时候我们要询问清楚面试官的要求。</p>
<p>方法二，我们可以用栈实现「后进先出」这种顺序，每经过一个节点的时候，把该节点放到一个栈中。当遍历完整个链表后，再从栈顶开始逐个输出节点的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> m_nValue;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>* <span class="title">m_pNext</span>;</span></span><br><span class="line">&#125; ListNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个链表元素</span></span><br><span class="line"><span class="function">ListNode* <span class="title">CreateListNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    ListNode* pNode = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));  <span class="comment">// 分配地址</span></span><br><span class="line">    pNode-&gt;m_nValue = value;</span><br><span class="line">    pNode-&gt;m_pNext = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> pNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链接两个链表元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConnectListNodes</span><span class="params">(ListNode* pCurrent, ListNode* pNext)</span> </span>&#123;</span><br><span class="line">    pCurrent-&gt;m_pNext = pNext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ListNode* pNode1 = CreateListNode(<span class="number">1</span>);</span><br><span class="line">    ListNode* pNode2 = CreateListNode(<span class="number">2</span>);</span><br><span class="line">    ListNode* pNode3 = CreateListNode(<span class="number">3</span>);</span><br><span class="line">    ListNode* pNode4 = CreateListNode(<span class="number">4</span>);</span><br><span class="line">    ListNode* pNode5 = CreateListNode(<span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    ConnectListNodes(pNode1, pNode2);</span><br><span class="line">    ConnectListNodes(pNode2, pNode3);</span><br><span class="line">    ConnectListNodes(pNode3, pNode4);</span><br><span class="line">    ConnectListNodes(pNode4, pNode5);</span><br><span class="line">    </span><br><span class="line">    ListNode* pNode = pNode1;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> nodes[<span class="number">100</span>] = &#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        nodes[num] = pNode-&gt;m_nValue;</span><br><span class="line">        pNode = pNode-&gt;m_pNext;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = num - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, nodes[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法三，既然想到了用栈来实现这个函数，而递归在本质上就是一个栈结构。要实现反过来输出链表，我们每访问到一个节点的时候，先递归输出它后面的节点，再输出该节点自身，这样链表的输出结果就反过来了。虽然基于递归的代码看起来很简洁，但有一个问题：当链表非常长的时候，就会导致函数调用的层级很深，从而有可能导致函数调用栈溢出。显然用栈基于循环实现的代码的鲁棒性要好一些。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintListReversingly_Recursively</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pHead-&gt;m_pNext != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PrintListReversingly_Recursively(pHead-&gt;m_pNext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, pHead-&gt;m_nValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ListNode* pNode1 = CreateListNode(<span class="number">1</span>);</span><br><span class="line">    ListNode* pNode2 = CreateListNode(<span class="number">2</span>);</span><br><span class="line">    ListNode* pNode3 = CreateListNode(<span class="number">3</span>);</span><br><span class="line">    ListNode* pNode4 = CreateListNode(<span class="number">4</span>);</span><br><span class="line">    ListNode* pNode5 = CreateListNode(<span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    ConnectListNodes(pNode1, pNode2);</span><br><span class="line">    ConnectListNodes(pNode2, pNode3);</span><br><span class="line">    ConnectListNodes(pNode3, pNode4);</span><br><span class="line">    ConnectListNodes(pNode4, pNode5);</span><br><span class="line">    </span><br><span class="line">    PrintListReversingly_Recursively(pNode1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-数据结构-树"><a href="#4-数据结构-树" class="headerlink" title="4. 数据结构 - 树"></a>4. 数据结构 - 树</h2><p>面试的时候提到的树，大部分是二叉树，其中最重要的操作莫过于遍历，通常树有如下几种遍历方式：</p>
<ul>
<li>前序遍历：先访问根节点，再访问左子节点，最后访问右子节点。图中前序遍历的顺序是 10、6、4、8、14、12、16；</li>
<li>中序遍历：先访问左子节点，再访问根节点，最后访问右子节点。图中中序遍历的顺序是 4、6、8、10、12、14、16；</li>
<li>后序遍历：先访问左子节点，再访问右子节点，最后访问根节点。图中后序遍历的顺序是 4、8、6、12、16、14、10；</li>
<li>宽度优先遍历：先访问树的第一层节点，再访问树的第二层节点，直到访问到最下面一层节点。图中宽度优先遍历的顺序是 10、6、14、4、8、12、16。</li>
</ul>
<p><img src="https://mayan29.oss-cn-beijing.aliyuncs.com/%E3%80%8A%E5%89%91%E6%8C%87%20Offer%20%E7%AC%AC2%E7%89%88%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/IMG001.png" alt="IMG001"></p>
<p>二叉树有很多特例，二叉搜索树就是其中之一。在二叉搜索树中，左子节点总是小于或等于根节点，右子节点总是大于或等于根节点，上图中的二叉树就是一颗二叉搜索树。我们可以平均在 O(logn) 的时间内根据数值在二叉搜索树中找到一个节点。</p>
<p>二叉树的另外两个特例是堆和红黑树。堆分为最大堆和最小堆，在最大堆中根节点的值最大，在最小堆中根节点的值最小，有很多需要快速找到最大值或者最小值的问题都可以用堆来解决。红黑树是把树中的节点定义为红、黑两种颜色，并通过规则确保从根节点到叶节点的最长路径的长度不超过最短路径的二倍。在 C++ 的 STL 中，set、multiset、map、multimap 等数据结构都是基于红黑树实现的。</p>
<h3 id="面试题-7"><a href="#面试题-7" class="headerlink" title="面试题 7"></a>面试题 7</h3><p><strong>题目：重建二叉树。</strong>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如，输入前序遍历序列 <code>{ 1, 2, 4, 7, 3, 5, 6, 8 }</code> 和中序遍历序列 <code>{ 4, 7, 2, 1, 5, 3, 8, 6 }</code>，则重建如下图所示的二叉树并输出它的头节点。二叉树节点的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">binaryTreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> m_nValue;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binaryTreeNode</span>* <span class="title">m_pLeft</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binaryTreeNode</span>* <span class="title">m_pRight</span>;</span></span><br><span class="line">&#125; BinaryTreeNode;</span><br></pre></td></tr></table></figure>

<p>前序遍历序列的第一个数字 1 就是根节点的值，根据中序遍历的特点，在根节点的值 1 前面的 3 个数字都是左子树节点的值，位于 1 后面的 4 个数字都是右子树节点的值。然后我们可以用同样的方法分别构建左、右子树。也就是说，接下来的事情可以用递归的方法去完成。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">binaryTreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> m_nValue;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binaryTreeNode</span>* <span class="title">m_pLeft</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binaryTreeNode</span>* <span class="title">m_pRight</span>;</span></span><br><span class="line">&#125; BinaryTreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个节点元素</span></span><br><span class="line"><span class="function">BinaryTreeNode* <span class="title">CreateBinaryTreeNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    BinaryTreeNode* pNode = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BinaryTreeNode));  <span class="comment">// 分配地址</span></span><br><span class="line">    pNode-&gt;m_nValue = value;</span><br><span class="line">    pNode-&gt;m_pLeft = <span class="literal">NULL</span>;</span><br><span class="line">    pNode-&gt;m_pRight = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> pNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链接父子节点元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConnectTreeNodes</span><span class="params">(BinaryTreeNode* pParent, BinaryTreeNode* pLeft, BinaryTreeNode* pRight)</span> </span>&#123;</span><br><span class="line">    pParent-&gt;m_pLeft = pLeft;</span><br><span class="line">    pParent-&gt;m_pRight = pRight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintTree</span><span class="params">(<span class="keyword">const</span> BinaryTreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pRoot == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"没有根节点\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"根节点 [%d]\t"</span>, pRoot-&gt;m_nValue);</span><br><span class="line">    pRoot-&gt;m_pLeft == <span class="literal">NULL</span> ? <span class="built_in">printf</span>(<span class="string">"左子节点 [无]\t"</span>) : <span class="built_in">printf</span>(<span class="string">"左子节点 [%d]\t"</span>, pRoot-&gt;m_pLeft-&gt;m_nValue);</span><br><span class="line">    pRoot-&gt;m_pRight == <span class="literal">NULL</span> ? <span class="built_in">printf</span>(<span class="string">"右子节点 [无]"</span>) : <span class="built_in">printf</span>(<span class="string">"右子节点 [%d]"</span>, pRoot-&gt;m_pRight-&gt;m_nValue);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pRoot-&gt;m_pLeft != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PrintTree(pRoot-&gt;m_pLeft);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pRoot-&gt;m_pRight != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PrintTree(pRoot-&gt;m_pRight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BinaryTreeNode* <span class="title">ConstructCore</span><span class="params">(<span class="keyword">int</span>* startPreorder, <span class="keyword">int</span>* endPreorder, <span class="keyword">int</span>* startInorder, <span class="keyword">int</span>* endInorder)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 前序遍历序列的第一个数字是根结点的值</span></span><br><span class="line">    <span class="keyword">int</span> rootValue = startPreorder[<span class="number">0</span>];</span><br><span class="line">    BinaryTreeNode* root = CreateBinaryTreeNode(rootValue);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (startPreorder == endPreorder) &#123;</span><br><span class="line">        <span class="keyword">if</span> (startInorder == endInorder &amp;&amp; *startPreorder == *startInorder) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在中序遍历中找到根结点的值</span></span><br><span class="line">    <span class="keyword">int</span>* rootInorder = startInorder;</span><br><span class="line">    <span class="keyword">while</span> (rootInorder &lt;= endInorder &amp;&amp; *rootInorder != rootValue) &#123;</span><br><span class="line">        ++rootInorder;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (rootInorder == endInorder &amp;&amp; *rootInorder != rootValue) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> leftLength = rootInorder - startInorder;</span><br><span class="line">    <span class="keyword">if</span> (leftLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 构建左子树</span></span><br><span class="line">        root-&gt;m_pLeft = ConstructCore(startPreorder + <span class="number">1</span>, startPreorder + leftLength, startInorder, rootInorder - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (leftLength &lt; endPreorder - startPreorder) &#123;</span><br><span class="line">        <span class="comment">// 构建右子树</span></span><br><span class="line">        root-&gt;m_pRight = ConstructCore(startPreorder + leftLength + <span class="number">1</span>, endPreorder, rootInorder + <span class="number">1</span>, endInorder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BinaryTreeNode* <span class="title">Construct</span><span class="params">(<span class="keyword">int</span> *preorder, <span class="keyword">int</span>* inorder, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preorder == <span class="literal">NULL</span> || inorder == <span class="literal">NULL</span> || length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ConstructCore(preorder, preorder + length - <span class="number">1</span>, inorder, inorder + length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> preorder[<span class="number">8</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> inorder[<span class="number">8</span>] = &#123; <span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span> &#125;;</span><br><span class="line">    </span><br><span class="line">    BinaryTreeNode* root = Construct(preorder, inorder, <span class="number">8</span>);  <span class="comment">// 生成树</span></span><br><span class="line">    PrintTree(root);  <span class="comment">// 打印树</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="面试题-8"><a href="#面试题-8" class="headerlink" title="面试题 8"></a>面试题 8</h3><p><strong>题目：二叉树的下一个节点。</strong>给定一棵二叉树和其中的一个节点，如何找出中序遍历序列的下一个节点？树中的节点除了有两个分别指向左、右子节点的指针，还有一个指向父节点的指针。</p>
<p>如下图的二叉树的中序遍历序列是 <code>{ d, b, h, e, i, a, f, c, g }</code>，我们将以这棵树为例来分析如何找出二叉树的下一个节点。</p>
<p><img src="https://mayan29.oss-cn-beijing.aliyuncs.com/%E3%80%8A%E5%89%91%E6%8C%87%20Offer%20%E7%AC%AC2%E7%89%88%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/IMG002.png" alt="IMG002"></p>
<ul>
<li>如果这个节点有右子树，那么它下一个节点就是它的右子树中的最左子节点；</li>
<li>如果这个节点没有右子树，但是这个节点是它父节点的左子节点，那么它的下一个节点就是它的父节点；</li>
<li>如果这个节点没有右子树，并且这个节点是它父节点的右子节点，我们可以沿着指向父节点的指针一直向上遍历，直到找到一个是它父节点的左子节点的节点，那么这个节点的父节点就是我们要找的下一个节点。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">binaryTreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> m_nValue;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binaryTreeNode</span>* <span class="title">m_pLeft</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binaryTreeNode</span>* <span class="title">m_pRight</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binaryTreeNode</span>* <span class="title">m_pParent</span>;</span></span><br><span class="line">&#125; BinaryTreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个节点元素</span></span><br><span class="line"><span class="function">BinaryTreeNode* <span class="title">CreateBinaryTreeNode</span><span class="params">(<span class="keyword">char</span> value)</span> </span>&#123;</span><br><span class="line">    BinaryTreeNode* pNode = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BinaryTreeNode));  <span class="comment">// 分配地址</span></span><br><span class="line">    pNode-&gt;m_nValue = value;</span><br><span class="line">    pNode-&gt;m_pLeft = <span class="literal">NULL</span>;</span><br><span class="line">    pNode-&gt;m_pRight = <span class="literal">NULL</span>;</span><br><span class="line">    pNode-&gt;m_pParent = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> pNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链接父子节点元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConnectTreeNodes</span><span class="params">(BinaryTreeNode* pParent, BinaryTreeNode* pLeft, BinaryTreeNode* pRight)</span> </span>&#123;</span><br><span class="line">    pParent-&gt;m_pLeft = pLeft;</span><br><span class="line">    pParent-&gt;m_pRight = pRight;</span><br><span class="line">    <span class="keyword">if</span> (pLeft != <span class="literal">NULL</span>) pLeft-&gt;m_pParent = pParent;</span><br><span class="line">    <span class="keyword">if</span> (pRight != <span class="literal">NULL</span>) pRight-&gt;m_pParent = pParent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BinaryTreeNode* <span class="title">GetNext</span><span class="params">(BinaryTreeNode* pNode)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pNode == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    BinaryTreeNode* pNext = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pNode-&gt;m_pRight != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        BinaryTreeNode* pCurrent = pNode-&gt;m_pRight;</span><br><span class="line">        <span class="keyword">while</span> (pCurrent-&gt;m_pLeft != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            pCurrent = pCurrent-&gt;m_pLeft;</span><br><span class="line">        &#125;</span><br><span class="line">        pNext = pCurrent;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pNode-&gt;m_pParent != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        BinaryTreeNode* pCurrent = pNode;</span><br><span class="line">        <span class="keyword">while</span> (pCurrent-&gt;m_pParent != <span class="literal">NULL</span> &amp;&amp; pCurrent == pCurrent-&gt;m_pParent-&gt;m_pRight) &#123;</span><br><span class="line">            pCurrent = pCurrent-&gt;m_pParent;</span><br><span class="line">        &#125;</span><br><span class="line">        pNext = pCurrent-&gt;m_pParent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pNext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    BinaryTreeNode* pNodeA = CreateBinaryTreeNode(<span class="string">'a'</span>);</span><br><span class="line">    BinaryTreeNode* pNodeB = CreateBinaryTreeNode(<span class="string">'b'</span>);</span><br><span class="line">    BinaryTreeNode* pNodeC = CreateBinaryTreeNode(<span class="string">'c'</span>);</span><br><span class="line">    BinaryTreeNode* pNodeD = CreateBinaryTreeNode(<span class="string">'d'</span>);</span><br><span class="line">    BinaryTreeNode* pNodeE = CreateBinaryTreeNode(<span class="string">'e'</span>);</span><br><span class="line">    BinaryTreeNode* pNodeF = CreateBinaryTreeNode(<span class="string">'f'</span>);</span><br><span class="line">    BinaryTreeNode* pNodeG = CreateBinaryTreeNode(<span class="string">'g'</span>);</span><br><span class="line">    BinaryTreeNode* pNodeH = CreateBinaryTreeNode(<span class="string">'h'</span>);</span><br><span class="line">    BinaryTreeNode* pNodeI = CreateBinaryTreeNode(<span class="string">'i'</span>);</span><br><span class="line">    </span><br><span class="line">    ConnectTreeNodes(pNodeA, pNodeB, pNodeC);</span><br><span class="line">    ConnectTreeNodes(pNodeB, pNodeD, pNodeE);</span><br><span class="line">    ConnectTreeNodes(pNodeC, pNodeF, pNodeG);</span><br><span class="line">    ConnectTreeNodes(pNodeE, pNodeH, pNodeI);</span><br><span class="line">    </span><br><span class="line">    BinaryTreeNode* pNode = GetNext(pNodeA);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"当前为最后一个节点，或者输入无效\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"当前节点的下一个节点为 %c\n"</span>, pNode-&gt;m_nValue);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-数据结构-栈和队列"><a href="#5-数据结构-栈和队列" class="headerlink" title="5. 数据结构 - 栈和队列"></a>5. 数据结构 - 栈和队列</h2><p>栈是一个非常常见的数据结构，比如操作系统会给每个线程创建一个栈用来存储函数调用时各个函数的参数、返回地址和临时变量等。栈的特点是后进先出，即最后被 Push 栈的元素会第一个被 Pop。通常栈是一个不考虑排序的数据结构，我们需要 O(n) 时间才能找到栈中最大或者最小的元素，如果想要在 O(1) 时间内得到栈的最大值或者最小值，则需要对栈做特殊的设计。</p>
<p>队列是另外一种很重要的数据结构，和栈不同的是，队列的特点是先进先出。</p>
<h3 id="面试题-9"><a href="#面试题-9" class="headerlink" title="面试题 9"></a>面试题 9</h3><p><strong>题目：用两个栈实现队列。</strong>请实现队列中的两个函数 <code>appendTail</code> 和 <code>deleteHead</code>，分别完成在队列尾部插入节点和在队列头部删除节点的功能。</p>
<p>这道题的意图是要求我们操作这两个「先进后出」的栈实现一个「先进先出」的队列。我们通过一个具体的例子来分析往该队列插入和删除元素的过程。首先插入一个元素 <code>a</code>，先把它插入 <code>stack1</code>，此时 <code>stack1</code> 中有元素 <code>{ a }</code>，<code>stack2</code> 为空。再压入两个元素 <code>b</code> 和 <code>c</code>，还是插入 <code>stack1</code>，此时 <code>stack1</code> 中的元素有 <code>{ a, b, c }</code>，其中 <code>c</code> 位于栈顶，而 <code>stack2</code> 仍然为空。</p>
<p>这时候我们从队列中删除一个元素，按照队列先入先出的规则，由于 <code>a</code> 比 <code>b</code>、<code>c</code> 先插入队列中，最先被删除的元素应该是 <code>a</code>。元素 <code>a</code> 存储在 <code>stack1</code> 中，但并不在栈顶上，因此不能直接删除。所以我们把 <code>stack1</code> 中的元素逐个弹出并压入 <code>stack2</code>，<code>stack1</code> 为空，而 <code>stack2</code> 中的元素是 <code>{ c, b, a }</code>，这时候就可以弹出 <code>stack2</code> 的栈顶 <code>a</code> 了。</p>
<p>从上面的分析中我们可以总结出：当 <code>stack2</code> 不为空时，在 <code>stack2</code> 中的栈顶元素是最先进入队列的元素，可以弹出。当 <code>stack2</code> 为空时，我们把 <code>stack1</code> 中的元素逐个弹出并压入 <code>stack2</code>。由于先进入队列的元素被压到 <code>stack1</code> 的底端，经过弹出和压入操作之后就处于 <code>stack2</code> 的顶端，又可以直接弹出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> stack1[<span class="number">100</span>] = &#123;&#125;;</span><br><span class="line"><span class="keyword">char</span> stack2[<span class="number">100</span>] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在队列末尾添加一个结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(stack1) / <span class="keyword">sizeof</span>(<span class="keyword">char</span>); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack1[i] == <span class="string">'\0'</span>) &#123;</span><br><span class="line">            stack1[i] = c;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在队列头部删除一个结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (stack2[<span class="number">0</span>] == <span class="string">'\0'</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(stack1) / <span class="keyword">sizeof</span>(<span class="keyword">char</span>); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stack1[i] == <span class="string">'\0'</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                    stack2[j] = stack1[i - j - <span class="number">1</span>];</span><br><span class="line">                    stack1[i - j - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">sizeof</span>(stack2) / <span class="keyword">sizeof</span>(<span class="keyword">char</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2[i] != <span class="string">'\0'</span>) &#123;</span><br><span class="line">            stack2[i] = <span class="string">'\0'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">sizeof</span>(stack2) / <span class="keyword">sizeof</span>(<span class="keyword">char</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2[i] != <span class="string">'\0'</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c\t"</span>, stack2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(stack1) / <span class="keyword">sizeof</span>(<span class="keyword">char</span>); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack1[i] != <span class="string">'\0'</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c\t"</span>, stack1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    appendTail(<span class="string">'a'</span>);</span><br><span class="line">    appendTail(<span class="string">'b'</span>);</span><br><span class="line">    appendTail(<span class="string">'c'</span>);</span><br><span class="line">    printQueue();</span><br><span class="line">    </span><br><span class="line">    deleteHead();</span><br><span class="line">    printQueue();</span><br><span class="line">    </span><br><span class="line">    appendTail(<span class="string">'d'</span>);</span><br><span class="line">    printQueue();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="面试题-9-附"><a href="#面试题-9-附" class="headerlink" title="面试题 9 - 附"></a>面试题 9 - 附</h3><p><strong>题目：</strong>用两个队列实现一个栈。</p>
<p>我们通过一系列栈的压入和弹出操作来分析用两个队列模拟一个栈的过程。我们先往栈内压入一个元素 <code>a</code>，由于两个队列现在都是空的，我们可以选择把 <code>a</code> 插入两个队列的任意一个，不妨把 <code>a</code> 插入 <code>queue1</code>。接下来继续往 <code>queue1</code> 压入 <code>b</code>、<code>c</code> 两个元素，这个时候 <code>queue1</code> 包含了 3 个元素 <code>{ a, b, c }</code>。</p>
<p>现在我们从栈内弹出一个元素，根据栈的后入先出原则，最后被压入栈的 <code>c</code> 应该最先被弹出。由于 <code>c</code> 位于 <code>queue1</code> 的尾部，而我们每次只能从队列的头部删除元素，因此我们可以先从 <code>queue1</code> 中依次删除元素 <code>a</code>、<code>b</code> 并插入 <code>queue2</code>，再从 <code>queue1</code> 中删除元素 <code>c</code>，这就相当于从栈中弹出元素 <code>c</code> 了。我们可以用同样的方法从栈内弹出元素 <code>b</code>。</p>
<p>接下来我们考虑往栈内压入一个元素 <code>d</code>，此时 <code>queue1</code> 已经有一个元素，我们就把 <code>d</code> 插入 <code>queue1</code> 的尾部。如果我们再从栈内弹出一个元素，那么此时被弹出的应该是最后被压入的 <code>d</code>。由于 <code>d</code> 位于 <code>queue1</code> 的尾部，我们只能先从头删除 <code>queue1</code> 的元素并插入 <code>queue2</code>，直到在 <code>queue1</code> 中遇到 <code>d</code> 再直接把它删除。</p>
<h2 id="6-算法和数据操作-递归和循环"><a href="#6-算法和数据操作-递归和循环" class="headerlink" title="6. 算法和数据操作 - 递归和循环"></a>6. 算法和数据操作 - 递归和循环</h2><p>递归是在一个函数的内部调用这个函数自身，而循环则是通过设置计算的初始值和终止条件，在一个范围内重复运算。通常递归的代码会比较简洁，在树的前序、中序、后序遍历算法的代码中，递归的实现明显要比循环简单得多。在面试的时候，如果面试官没有特别的要求，可以尽量多采用递归的方法编程。递归虽然有简洁的优点，但它同时也有显著的缺点：</p>
<ol>
<li>递归由于是函数调用自身，而函数调用是有时间和空间的消耗的：每一次函数调用，都需要在内存栈中分配空间以保存参数、返回地址和临时变量，而且往栈里压入数据和弹出数据都需要时间，所以递归实现的效率不如循环；</li>
<li>递归中有可能很多计算都是重复的，从而对性能带来很大的负面影响。递归的本质是把一个问题分解成两个或者多个小问题。如果多个小问题存在相互重叠的部分，就存在重复的计算；</li>
<li>除效率之外，递归还有可能引起更严重的问题：调用栈溢出。在前面的分析中提到需要为每一次函数调用在内存栈中分配空间，而每个进程的栈的容量是有限的，当递归调用的层级太多时，就会超出栈的容量，从而导致调用栈溢出。</li>
</ol>
<h3 id="面试题-10-1"><a href="#面试题-10-1" class="headerlink" title="面试题 10 - 1"></a>面试题 10 - 1</h3><p><strong>题目：斐波那契数列。</strong>写一个函数，输入 n，求斐波那契数列的第 n 项。斐波那契数列的定义如下：</p>
<p><img src="https://mayan29.oss-cn-beijing.aliyuncs.com/%E3%80%8A%E5%89%91%E6%8C%87%20Offer%20%E7%AC%AC2%E7%89%88%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/IMG003.png" alt="IMG003"></p>
<p>方法一，很多 C 语言教科书在讲述斐波那契数列的时候，常用递归的解法，效率很低，挑剔的面试官不会喜欢。我们以求解 <code>f(10)</code> 为例来分析递归的求解过程，用树形结构来表示这种依赖关系，如下图所示：</p>
<p><img src="https://mayan29.oss-cn-beijing.aliyuncs.com/%E3%80%8A%E5%89%91%E6%8C%87%20Offer%20%E7%AC%AC2%E7%89%88%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/IMG004.png" alt="IMG004"></p>
<p>我们不难发现，在这棵树中有很多节点是重复的，而且重复的节点数会随着 n 的增大而急剧增加，用递归方法计算的时间复杂度是以 n 的指数的方式递增的。读者不妨求斐波那契数列的第 100 项试试，感受一下这样递归会慢到什么程度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Fibonacci(<span class="number">10</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，上述递归代码之所以慢，是因为重复的计算太多。我们可以从下往上计算，首先根据 <code>f(0)</code> 和 <code>f(1)</code> 算出 <code>f(2)</code>，在根据 <code>f(1)</code> 和 <code>f(2)</code> 算出 <code>f(3)</code>，以此类推就可以算出第 n 项了，这种思路的时间复杂度是 O(n) 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fibNMinusOne = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fibNMinusTwo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fibN = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        fibN = fibNMinusOne + fibNMinusTwo;</span><br><span class="line">        fibNMinusTwo = fibNMinusOne;</span><br><span class="line">        fibNMinusOne = fibN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fibN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Fibonacci(<span class="number">100</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法三</p>
<p><img src="https://mayan29.oss-cn-beijing.aliyuncs.com/%E3%80%8A%E5%89%91%E6%8C%87%20Offer%20%E7%AC%AC2%E7%89%88%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/IMG005.jpeg" alt="IMG005"></p>
<p>代码地址：<a href="https://github.com/zhedahht/CodingInterviewChinese2/blob/master/10_Fibonacci/Fibonacci.cpp" target="_blank" rel="noopener">https://github.com/zhedahht/CodingInterviewChinese2/blob/master/10_Fibonacci/Fibonacci.cpp</a></p>
<h3 id="面试题-10-2"><a href="#面试题-10-2" class="headerlink" title="面试题 10 - 2"></a>面试题 10 - 2</h3><p><strong>题目：青蛙跳台阶问题。</strong>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级台阶。求该青蛙跳上一个 n 级台阶总共有多少种跳法。</p>
<p>首先我们考虑最简单的情况：只有 1 级台阶，那显然只有一种跳法；如果有 2 级台阶，可以跳两次，一次跳 1 级，或者跳一次，跳 2 级。</p>
<p>接着我们再来讨论一般情况：我们把 n 级台阶时的跳法看成 n 的函数 <code>f(n)</code>，当 n &gt; 2 时，第一次跳的时候就有两种不同的选择：一是第一次只跳 1 级，此时跳法数目等于后面剩下的 n - 1 级台阶的跳法数目，即为 <code>f(n-1)</code>；二是第一次跳 2 级，此时跳法数目等于后面剩下的 n - 2 级台阶的跳法数目，即为 <code>f(n-2)</code>。因此，n 级台阶的不同跳法的总数 <code>f(n)=f(n-1)+f(n-2)</code>。分析到这里，我们不难看出这实际上就是斐波那契数列了。</p>
<h3 id="面试题-10-附-1"><a href="#面试题-10-附-1" class="headerlink" title="面试题 10 - 附 1"></a>面试题 10 - 附 1</h3><p><strong>题目：</strong>在青蛙跳台阶的问题中，如果把条件改成：一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级台阶，也可以跳上 n 级台阶，此时该青蛙跳上一个 n 级的台阶总共有多少种跳法？</p>
<p>我们用数学归纳法可以证明 <code>f(n)=2^(n-1)</code>。</p>
<h3 id="面试题-10-附-2"><a href="#面试题-10-附-2" class="headerlink" title="面试题 10 - 附 2"></a>面试题 10 - 附 2</h3><p><strong>题目：</strong>我们可以用 2×1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 8 个 2×1 的小矩形无重叠地覆盖一个 2×8 的大矩形，总共有多少种方法？</p>
<p><img src="https://mayan29.oss-cn-beijing.aliyuncs.com/%E3%80%8A%E5%89%91%E6%8C%87%20Offer%20%E7%AC%AC2%E7%89%88%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/IMG006.png" alt="IMG006"></p>
<p>同样是斐波那契数列。</p>
<h2 id="7-算法和数据操作-查找和排序"><a href="#7-算法和数据操作-查找和排序" class="headerlink" title="7. 算法和数据操作 - 查找和排序"></a>7. 算法和数据操作 - 查找和排序</h2><p>查找和排序都是在程序设计中经常用到的算法。查找相对而言较为简单，不外乎顺序查找、二分查找、哈希表查找和二叉排序树查找。在面试的时候，不管是用循环还是用递归，面试官都期待应聘者能够信手拈来写出完整正确的二分查找代码。哈希表和二叉排序树查找的重点在于考察对应的数据结构而不是算法。哈希表最主要的优点是我们利用它能够在 O(1) 时间内查找某一元素，但其缺点是需要额外的空间来实现哈希表。</p>
<p>排序比查找要复杂一些，面试官会经常要求应聘者比较插入排序、冒泡排序、归并排序、快速排序等不同算法的优劣。强烈建议应聘者对各种排序算法的特点烂熟于胸，能够从额外空间消耗、平均时间复杂度和最差时间复杂度等方面去比较它们的优缺点。很多公司的面试官喜欢在面试环节要求应聘者写出快速排序的代码。</p>
<p>实现快速排序算法的关键在于先在数组中选择一个数字，接下来把数组中的数字分为两部分，比选择的数字小的数字移到数组的左边，比选择的数字大的数字移到数组的右边。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span>* x, <span class="keyword">int</span>* y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分区</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小于参考值的最后一个数的角标</span></span><br><span class="line">    <span class="keyword">int</span> lastSmall = start - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">        <span class="comment">// 将 arr[end] 作为参考值</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[end]) &#123;</span><br><span class="line">            lastSmall++;</span><br><span class="line">            <span class="keyword">if</span> (lastSmall != i) &#123;</span><br><span class="line">                Swap(&amp;arr[i], &amp;arr[lastSmall]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最后将参考值和大于或等于参考值第一个数交换</span></span><br><span class="line">    Swap(&amp;arr[lastSmall + <span class="number">1</span>], &amp;arr[end]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> lastSmall + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (start == end) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> index = Partition(arr, start, end);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (index &gt; start) &#123;</span><br><span class="line">        QuickSort(arr, start, index - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; end) &#123;</span><br><span class="line">        QuickSort(arr, index + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123; <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span> &#125;;</span><br><span class="line">    </span><br><span class="line">    QuickSort(arr, <span class="number">0</span>, <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>) - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>); i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不同的排序算法适用的场合也不尽相同，快速排序虽然总体的平均效率是最好的，但也不是任何时候都是最优的算法。在面试的时候，如果面试官要求实现一个排序算法，那么应聘者一定要问清楚这个排序应用的环境是什么、有哪些约束条件、是否可以用辅助内存。比如对公司员工年龄进行排序，下面的方法用长度 100 的整数数组作为辅助控件换来了 O(n) 的时间效率：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SortAges</span><span class="params">(<span class="keyword">int</span> ages[], <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ages == <span class="literal">NULL</span> || length &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 公司员工年龄范围 0 ~ 99</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> oldestAge = <span class="number">99</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 统计每个年龄出现的次数</span></span><br><span class="line">    <span class="keyword">int</span> timesOfAge[oldestAge + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= oldestAge; i++) &#123;</span><br><span class="line">        timesOfAge[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        timesOfAge[ages[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= oldestAge; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; timesOfAge[i]; j++) &#123;</span><br><span class="line">            ages[index] = i;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="面试题-11"><a href="#面试题-11" class="headerlink" title="面试题 11"></a>面试题 11</h3><p><strong>题目：旋转数组的最小数字。</strong>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 <code>{ 3, 4, 5, 1, 2 }</code> 为 <code>{ 1, 2, 3, 4, 5 }</code> 的一个旋转，该数组的最小值为 1。</p>
<p>本题给出的数组在一定程度上是排序的，因此我们可以用二分查找法的思路来寻找这个最小的元素。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinInOrder</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> result = numbers[index1];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index1 + <span class="number">1</span>; i &lt;= index2 ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (result &gt; numbers[i]) &#123;</span><br><span class="line">            result = numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> index1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index2 = length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> indexMid = index1;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (numbers[index1] &gt;= numbers[index2]) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果 index1 和 index2 指向相邻的两个数，则 index1 指向第一个递增子数组的最后一个数字，index2 指向第二个子数组的第一个数字，也就是数组中的最小数字</span></span><br><span class="line">        <span class="keyword">if</span> (index2 - index1 == <span class="number">1</span>) &#123;</span><br><span class="line">            indexMid = index2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        indexMid = (index1 + index2) / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果下标为 index1、index2 和 indexMid 指向的三个数字相等，则只能顺序查找</span></span><br><span class="line">        <span class="keyword">if</span> (numbers[index1] == numbers[index2] &amp;&amp; numbers[index1] == numbers[indexMid]) &#123;</span><br><span class="line">            <span class="keyword">return</span> MinInOrder(numbers, index1, index2);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 缩小查找范围</span></span><br><span class="line">        <span class="keyword">if</span> (numbers[indexMid] &gt;= numbers[index1]) &#123;</span><br><span class="line">            index1 = indexMid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[indexMid] &lt;= numbers[index2]) &#123;</span><br><span class="line">            index2 = indexMid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numbers[indexMid];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> numbers[<span class="number">5</span>] = &#123; <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> min = Min(numbers, <span class="keyword">sizeof</span>(numbers) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, min);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-算法和数据操作-回溯法"><a href="#8-算法和数据操作-回溯法" class="headerlink" title="8. 算法和数据操作 - 回溯法"></a>8. 算法和数据操作 - 回溯法</h2><p>如果面试题要求在二维数组（可能具体表现为迷宫或者棋盘等）上搜索路径，那么我们可以尝试用回溯法。通常回溯法很适合用递归的代码实现。只有当面试官限定不可以用递归实现的时候，我们再考虑用栈来模拟递归的过程。</p>
<p>回溯法可以看成蛮力法的升级版，它从解决问题每一步的所有可能选项里系统地选择出一个可行的解决方案。回溯法非常适合由多个步骤组成的问题，并且每个步骤都有多个选项。当我们在某一步选择了其中一个选项时，就进入下一步，然后又面临新的选项。我们就这样重复选择，直至到达最终的状态。</p>
<p>用回溯法解决的问题的所有选项可以形象地用树状结构表示，树的叶节点对应着终结状态，如果在叶节点的状态满足题目的约束条件，那么我们找到了一个可行的解决方案。如果在叶节点的状态不满足约束条件，那么只好回溯到它的上一个节点再尝试其他的选项。</p>
<h3 id="面试题-12"><a href="#面试题-12" class="headerlink" title="面试题 12"></a>面试题 12</h3><p><strong>题目：矩阵中的路径。</strong>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的 3×4 的矩阵中包含一条字符串 <code>bfce</code> 的路径，但矩阵中不包含字符串 <code>abfb</code> 的路径，因为字符串的第一个字符 b 占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p>
<p><img src="https://mayan29.oss-cn-beijing.aliyuncs.com/%E3%80%8A%E5%89%91%E6%8C%87%20Offer%20%E7%AC%AC2%E7%89%88%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/IMG007.png" alt="IMG007"></p>
<p>这是一个可以用回溯法解决的典型题，由于回溯法的递归特性，路径可以被看成一个栈。当在矩阵中定位了路径中前 n 个字符的位置之后，在与第 n 个字符对应的格子的周围都没有找到第 n+1 个字符，这时候只好在路径上回到第 n-1个字符，重新定位第 n 个字符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPathCore</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">int</span> pathLength, <span class="keyword">bool</span>* visited)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (str[pathLength] == <span class="string">'\0'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> hasPath = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (row &gt;= <span class="number">0</span> &amp;&amp; row &lt; rows &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; cols &amp;&amp; matrix[row * cols + col] == str[pathLength] &amp;&amp; visited[row * cols + col] == <span class="literal">false</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        pathLength++;</span><br><span class="line">        visited[row * cols + col] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        hasPath =</span><br><span class="line">            hasPathCore(matrix, rows, cols, row, col - <span class="number">1</span>, str, pathLength, visited) ||</span><br><span class="line">            hasPathCore(matrix, rows, cols, row - <span class="number">1</span>, col, str, pathLength, visited) ||</span><br><span class="line">            hasPathCore(matrix, rows, cols, row, col + <span class="number">1</span>, str, pathLength, visited) ||</span><br><span class="line">            hasPathCore(matrix, rows, cols, row + <span class="number">1</span>, col, str, pathLength, visited);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!hasPath) &#123;</span><br><span class="line">            pathLength--;</span><br><span class="line">            visited[row * cols + col] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hasPath;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">const</span> <span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="literal">NULL</span> || rows &lt; <span class="number">1</span> || cols &lt; <span class="number">1</span> || str == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> pathLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; rows; row++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; cols; col++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 布尔值矩阵，用来标识路径是否已经进入了每个格子</span></span><br><span class="line">            <span class="keyword">bool</span> visited[rows * cols];</span><br><span class="line">            <span class="keyword">if</span> (hasPathCore(matrix, rows, cols, row, col, str, pathLength, visited)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* matrix = <span class="string">"ABTGCFCSJDEH"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">"BFCE"</span>;</span><br><span class="line">    </span><br><span class="line">    BOOL has = hasPath(matrix, <span class="number">3</span>, <span class="number">4</span>, str);</span><br><span class="line">       </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, has);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="面试题-13"><a href="#面试题-13" class="headerlink" title="面试题 13"></a>面试题 13</h3><p><strong>题目：机器人的运动范围。</strong>地上有一个 m 行 n 列的方格，一个机器人从坐标 <code>(0, 0)</code> 的格子开始移动，它每次可以向左、右、上、下移动一格，但不能进入行坐标和列坐标的数位之和大于 k 的格子。例如，当 k 为 18 时，机器人能够进入方格 <code>(35, 37)</code>，因为 3+5+3+7=18。但它不能进入方格 <code>(35, 38)</code>，因为 3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDigitSum</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> number / <span class="number">1</span> % <span class="number">10</span> + number / <span class="number">10</span> % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">movingCountCore</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">bool</span>* visited)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (row &gt;= <span class="number">0</span> &amp;&amp; row &lt; rows &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; cols &amp;&amp; getDigitSum(row) + getDigitSum(col) &lt;= threshold &amp;&amp; visited[row* cols + col] == <span class="literal">false</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        visited[row * cols + col] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">        count += movingCountCore(threshold, rows, cols, row - <span class="number">1</span>, col, visited);</span><br><span class="line">        count += movingCountCore(threshold, rows, cols, row, col - <span class="number">1</span>, visited);</span><br><span class="line">        count += movingCountCore(threshold, rows, cols, row + <span class="number">1</span>, col, visited);</span><br><span class="line">        count += movingCountCore(threshold, rows, cols, row, col + <span class="number">1</span>, visited);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (threshold &lt; <span class="number">0</span> || rows &lt;= <span class="number">0</span> || cols &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> visited[rows * cols];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows * cols; i++) &#123;</span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> count = movingCountCore(threshold, rows, cols, <span class="number">0</span>, <span class="number">0</span>, visited);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> rows = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> cols = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> threshold = <span class="number">5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> count = movingCount(threshold, rows, cols);</span><br><span class="line">       </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, count);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-算法和数据操作-动态规划与贪婪算法"><a href="#9-算法和数据操作-动态规划与贪婪算法" class="headerlink" title="9. 算法和数据操作 - 动态规划与贪婪算法"></a>9. 算法和数据操作 - 动态规划与贪婪算法</h2><p>如果面试题是求某个问题的最优解，并且该问题可以分为多个子问题，那么我们可以尝试用动态规划。在用自上而下的递归思路去分析动态规划问题的时候，我们会发现子问题之间存在重叠的更小的子问题。为了避免不必要的重复计算，我们用自下而上的循环代码来实现，也就是把子问题的最优解先算出来并用数组（一维或者二维数组）保存下来，接下来基于子问题的解计算大问题的解。</p>
<p>如果我们告诉面试官动态规划的思路之后，面试官还在提醒说再分解子问题的时候是不是存在某个特殊的选择，如果采用这个特殊的选择将一定能得到最优解，那么，通常面试官这样的提示意味着该面试题可能适用于贪婪算法。当然面试官也会要求应聘者证明贪婪选择的确最终能够得到最优解。</p>
<h3 id="面试题-14"><a href="#面试题-14" class="headerlink" title="面试题 14"></a>面试题 14</h3><p><strong>题目：剪绳子。</strong>给你一根长度为 n 的绳子，请把绳子剪成 m 段（m、n 都是整数，n&gt;1，m&gt;1），每段绳子的长度记为 k[0], k[1], ···, k[m]。请问 k[0] × k[1] × ··· × k[m] 可能的最大乘积是多少？例如，当绳子的长度是 8 时，我们把它剪成长度分别为 2、3、3 的三段，此时得到的最大乘积是 18。</p>
<p>方法一，动态规划。</p>
<h2 id="10-算法和数据操作-位运算"><a href="#10-算法和数据操作-位运算" class="headerlink" title="10. 算法和数据操作 - 位运算"></a>10. 算法和数据操作 - 位运算</h2><p>位运算可以看成一类特殊的算法，它是把数字表示成二进制之后对 0 和 1 的操作。一般总共只有与、或、异或、左移和右移 5 种位运算。</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/07/05/%E3%80%8A%E5%89%91%E6%8C%87%20Offer%20%E7%AC%AC%202%20%E7%89%88%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/" rel="prev" title="《剑指 Offer 第 2 版》读书笔记（二）">
                《剑指 Offer 第 2 版》读书笔记（二） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">mayan</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/%20%7C%7C%20archive">
                
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/%20%7C%7C%20th">
                    
                  
                    
                    
                      
                    
                    <span class="site-state-item-count">1</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第-1-章-面试的流程"><span class="nav-text">第 1 章 面试的流程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-简历中描述项目的-STAR-模型"><span class="nav-text">1. 简历中描述项目的 STAR 模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-简历中技能的描述"><span class="nav-text">2. 简历中技能的描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-回答「为什么跳槽」"><span class="nav-text">3. 回答「为什么跳槽」</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-技术面试环节"><span class="nav-text">4. 技术面试环节</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-回答「你还有什么问题吗」"><span class="nav-text">5. 回答「你还有什么问题吗」</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-2-章-面试需要的基础知识"><span class="nav-text">第 2 章 面试需要的基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-数据结构-数组"><span class="nav-text">1. 数据结构 - 数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#面试题-3-1"><span class="nav-text">面试题 3 - 1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面试题-3-2"><span class="nav-text">面试题 3 - 2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面试题-4"><span class="nav-text">面试题 4</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-数据结构-字符串"><span class="nav-text">2. 数据结构 - 字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#面试题-5"><span class="nav-text">面试题 5</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-数据结构-链表"><span class="nav-text">3. 数据结构 - 链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#面试题-6"><span class="nav-text">面试题 6</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-数据结构-树"><span class="nav-text">4. 数据结构 - 树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#面试题-7"><span class="nav-text">面试题 7</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面试题-8"><span class="nav-text">面试题 8</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-数据结构-栈和队列"><span class="nav-text">5. 数据结构 - 栈和队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#面试题-9"><span class="nav-text">面试题 9</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面试题-9-附"><span class="nav-text">面试题 9 - 附</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-算法和数据操作-递归和循环"><span class="nav-text">6. 算法和数据操作 - 递归和循环</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#面试题-10-1"><span class="nav-text">面试题 10 - 1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面试题-10-2"><span class="nav-text">面试题 10 - 2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面试题-10-附-1"><span class="nav-text">面试题 10 - 附 1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面试题-10-附-2"><span class="nav-text">面试题 10 - 附 2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-算法和数据操作-查找和排序"><span class="nav-text">7. 算法和数据操作 - 查找和排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#面试题-11"><span class="nav-text">面试题 11</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-算法和数据操作-回溯法"><span class="nav-text">8. 算法和数据操作 - 回溯法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#面试题-12"><span class="nav-text">面试题 12</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面试题-13"><span class="nav-text">面试题 13</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-算法和数据操作-动态规划与贪婪算法"><span class="nav-text">9. 算法和数据操作 - 动态规划与贪婪算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#面试题-14"><span class="nav-text">面试题 14</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-算法和数据操作-位运算"><span class="nav-text">10. 算法和数据操作 - 位运算</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mayan</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.1.2</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.2"></script>

  <script src="/js/motion.js?v=7.1.2"></script>



  
  


  <script src="/js/affix.js?v=7.1.2"></script>

  <script src="/js/schemes/pisces.js?v=7.1.2"></script>



  
  <script src="/js/scrollspy.js?v=7.1.2"></script>
<script src="/js/post-details.js?v=7.1.2"></script>



  


  <script src="/js/next-boot.js?v=7.1.2"></script>


  

  

  

  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
